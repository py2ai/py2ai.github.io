<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fingerprint Capture â€“ Quality Guided</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: Arial, sans-serif;
}

.container {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.box {
    flex: 1;
    position: relative;
    overflow: hidden;
}

video, canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

video { z-index: 1; }
#maskCanvas { z-index: 2; }
#bwCanvas { z-index: 1; }

.overlay {
    position: absolute;
    inset: 0;
    z-index: 3;
    pointer-events: none;
}

.controls {
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 4;
    pointer-events: auto;
}

button {
    background: #222;
    color: #fff;
    border: 1px solid #444;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
}

.arrow {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: bold;
}

.scoreText {
    position: absolute;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 13px;
}

/* Quality donut */
#donut {
    position: absolute;
    bottom: 60px;
    right: 12px;
    width: 80px;
    height: 80px;
    z-index: 4;
}
</style>
</head>

<body>

<div class="container">

<!-- TOP -->
<div class="box">
    <video id="video" autoplay playsinline></video>
    <canvas id="maskCanvas"></canvas>

    <canvas id="donut"></canvas>

    <div class="controls">
        <button id="torchBtn">ðŸ”¦ Torch ON</button>
    </div>

    <div class="overlay">
        <div id="arrow" class="arrow">â¬† Move Closer</div>
        <div id="scoreTop" class="scoreText">Quality: 0</div>
    </div>
</div>

<!-- BOTTOM -->
<div class="box">
    <canvas id="bwCanvas"></canvas>
    <div class="overlay">
        <div class="scoreText">Peak: <span id="peakScore">0</span></div>
    </div>
</div>

</div>

<script>
const video = document.getElementById("video");
const maskCanvas = document.getElementById("maskCanvas");
const maskCtx = maskCanvas.getContext("2d");
const bwCanvas = document.getElementById("bwCanvas");
const bwCtx = bwCanvas.getContext("2d");

const donutCanvas = document.getElementById("donut");
const donutCtx = donutCanvas.getContext("2d");

const arrow = document.getElementById("arrow");
const scoreTop = document.getElementById("scoreTop");
const peakScoreEl = document.getElementById("peakScore");
const torchBtn = document.getElementById("torchBtn");

let peakScore = 0;
let videoTrack = null;
let torchOn = false;

// Camera init (macro-optimized)
navigator.mediaDevices.getUserMedia({
    video: {
        facingMode: { ideal: "environment" },
        focusMode: "continuous",
        exposureMode: "continuous"
    }
}).then(stream => {
    video.srcObject = stream;
    videoTrack = stream.getVideoTracks()[0];

    const caps = videoTrack.getCapabilities?.();
    if (caps?.focusDistance) {
        videoTrack.applyConstraints({
            advanced: [{ focusDistance: caps.focusDistance.min }]
        });
    }
});

// Torch
torchBtn.onclick = async () => {
    if (!videoTrack) return;
    try {
        torchOn = !torchOn;
        await videoTrack.applyConstraints({
            advanced: [{ torch: torchOn }]
        });
        torchBtn.textContent = torchOn ? "ðŸ”¦ Torch OFF" : "ðŸ”¦ Torch ON";
    } catch {
        alert("Torch not supported");
    }
};

// Resize
function resize() {
    const w = video.videoWidth || 640;
    const h = video.videoHeight || 480;
    maskCanvas.width = bwCanvas.width = w;
    maskCanvas.height = bwCanvas.height = h;
    donutCanvas.width = donutCanvas.height = 80;
}
video.addEventListener("loadedmetadata", resize);

// ROI
function drawROI() {
    const w = maskCanvas.width;
    const h = maskCanvas.height;
    const roiW = w * 0.72;
    const roiH = h * 0.48;
    const x = (w - roiW) / 2;
    const y = h * 0.22;

    maskCtx.clearRect(0,0,w,h);
    maskCtx.fillStyle = "rgba(0,0,0,0.75)";
    maskCtx.fillRect(0,0,w,h);
    maskCtx.globalCompositeOperation = "destination-out";
    maskCtx.fillRect(x, y, roiW, roiH);
    maskCtx.globalCompositeOperation = "source-over";

    return { x, y, w: roiW, h: roiH };
}

// Draw quality donut
function drawDonut(value) {
    const ctx = donutCtx;
    const r = 34;
    const cx = 40;
    const cy = 40;
    const pct = Math.min(1, value);

    ctx.clearRect(0,0,80,80);

    // Background ring
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();

    // Color by quality
    let color = pct < 0.4 ? "#ff4444" : pct < 0.7 ? "#ffaa00" : "#00ff88";

    ctx.strokeStyle = color;
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI/2, -Math.PI/2 + pct * Math.PI * 2);
    ctx.stroke();
}

// Processing
function process() {
    if (!bwCanvas.width) return requestAnimationFrame(process);

    const roi = drawROI();

    bwCtx.drawImage(video,
        roi.x, roi.y, roi.w, roi.h,
        roi.x, roi.y, roi.w, roi.h
    );

    let img = bwCtx.getImageData(roi.x, roi.y, roi.w, roi.h);
    let d = img.data;

    let sumEdges = 0, sum = 0, sumSq = 0;

    for (let i = 0; i < d.length; i += 4) {
        let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];

        // Sharpen + contrast
        g = Math.min(255, Math.max(0, (g - 128) * 1.7 + 128));

        d[i] = d[i+1] = d[i+2] = g;
        sum += g;
        sumSq += g*g;
        if (i > 4) sumEdges += Math.abs(g - d[i-4]);
    }

    let mean = sum / (d.length / 4);
    for (let i = 0; i < d.length; i += 4) {
        let bw = d[i] < mean ? 0 : 255;
        d[i] = d[i+1] = d[i+2] = bw;
    }

    bwCtx.putImageData(img, roi.x, roi.y);

    let variance = sumSq / (d.length / 4) - mean * mean;
    let score = Math.round(sumEdges + variance);

    if (score > peakScore) {
        peakScore = score;
        peakScoreEl.textContent = peakScore;
    }

    scoreTop.textContent = `Quality: ${score}`;

    const norm = peakScore ? score / peakScore : 0;
    drawDonut(norm);

    if (norm < 0.85) arrow.textContent = "â¬† Move Closer";
    else if (norm > 1.05) arrow.textContent = "â¬‡ Move Away";
    else arrow.textContent = "âœ” BEST";

    requestAnimationFrame(process);
}

process();
</script>

</body>
</html>
